// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User management
model User {
  id                 String    @id @default(cuid())
  email              String    @unique
  emailVerified      Boolean   @default(false)
  emailVerifiedAt    DateTime?
  name               String?
  password           String // bcrypt hash
  role               Role      @default(CUSTOMER)
  isActive           Boolean   @default(true)
  isTwoFactorEnabled Boolean   @default(false)
  twoFactorSecret    String? // TOTP secret for 2FA
  lastLogin          DateTime?
  loginAttempts      Int       @default(0)
  lockedUntil        DateTime?
  profile            Json? // Additional profile data
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relations
  orders             Order[]
  configurations     Configuration[]
  auditLogs          AuditLog[]
  refreshTokens      RefreshToken[]
  passwordResets     PasswordReset[]
  emailVerifications EmailVerification[]
  sessions           Session[]
  trustedDevices     TrustedDevice[]

  @@map("users")
}

enum Role {
  CUSTOMER
  ADMIN
  SUPPORT
}

// Component catalog with assembly instructions
model Component {
  id             String            @id @default(cuid())
  name           String
  description    String?
  category       ComponentCategory
  price          Float
  availability   String            @default("in-stock")
  imageUrl       String?
  specifications Json?

  // Manual/Assembly data
  instructions    String? // Assembly instructions text
  toolsRequired   Json? // Array of required tools
  timeEstimate    Int? // Estimated assembly time in minutes
  difficultyLevel DifficultyLevel @default(BEGINNER)
  prerequisites   Json? // Array of component IDs that must be installed first

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  orderItems       OrderItem[]
  configComponents ConfigComponent[]
  manuals          Manual[]

  @@map("components")
}

enum ComponentCategory {
  HEAD
  TORSO
  ARMS
  LEGS
  SENSORS
  ACTUATORS
  ELECTRONICS
  ACCESSORIES
}

enum DifficultyLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

// Legacy Product model for backward compatibility
model Product {
  id             String   @id @default(cuid())
  name           String
  description    String?
  category       String
  price          Float
  availability   String   @default("in-stock")
  imageUrl       String?
  specifications Json?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  orderItems       OrderItem[]
  configComponents ConfigComponent[]

  @@map("products")
}

// Configuration system
model Configuration {
  id          String   @id @default(cuid())
  name        String
  description String?
  totalPrice  Float
  metadata    Json?
  isPublic    Boolean  @default(false) // Allow sharing configurations
  tags        Json? // Search tags for configurations
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  userId     String?
  user       User?             @relation(fields: [userId], references: [id], onDelete: SetNull)
  components ConfigComponent[]
  orders     Order[]
  manuals    Manual[]

  @@map("configurations")
}

model ConfigComponent {
  id            String @id @default(cuid())
  componentType String // head, torso, arms, legs, etc.
  options       Json? // customization options
  quantity      Int    @default(1)

  // Relations
  configurationId String
  configuration   Configuration @relation(fields: [configurationId], references: [id], onDelete: Cascade)
  productId       String?
  product         Product?      @relation(fields: [productId], references: [id])
  componentId     String?
  component       Component?    @relation(fields: [componentId], references: [id])

  @@map("config_components")
}

// Order management
model Order {
  id                String        @id @default(cuid())
  orderNumber       String        @unique
  status            OrderStatus   @default(PENDING)
  total             Float
  paymentMethod     String? // stripe, paypal
  paymentId         String? // external payment ID
  paymentStatus     PaymentStatus @default(PENDING)
  trackingNumber    String? // shipping tracking number
  shippingMethod    String? // standard, express, overnight
  estimatedDelivery DateTime?
  notes             String?
  customerInfo      Json // name, email, address
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  userId          String?
  user            User?          @relation(fields: [userId], references: [id], onDelete: SetNull)
  configurationId String?
  configuration   Configuration? @relation(fields: [configurationId], references: [id], onDelete: SetNull)
  items           OrderItem[]
  payments        Payment[]
  manuals         Manual[]

  @@map("orders")
}

enum OrderStatus {
  PENDING
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

model OrderItem {
  id       String @id @default(cuid())
  name     String
  price    Float
  quantity Int
  options  Json? // product customizations

  // Relations
  orderId     String
  order       Order      @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId   String?
  product     Product?   @relation(fields: [productId], references: [id], onDelete: SetNull)
  componentId String?
  component   Component? @relation(fields: [componentId], references: [id], onDelete: SetNull)

  @@map("order_items")
}

// Payment tracking
model Payment {
  id          String        @id @default(cuid())
  paymentId   String        @unique // external payment ID
  provider    String // stripe, paypal
  amount      Float
  currency    String        @default("USD")
  status      PaymentStatus
  paymentData Json? // raw payment data from provider
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relations
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@map("payments")
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

// System configuration
model SystemConfig {
  id        String   @id @default(cuid())
  key       String   @unique
  value     Json
  updatedAt DateTime @updatedAt

  @@map("system_config")
}

// Assembly manuals for orders/configurations
model Manual {
  id        String       @id @default(cuid())
  title     String
  content   String // Generated assembly instructions
  format    ManualFormat @default(HTML)
  version   String       @default("1.0")
  language  String       @default("en")
  status    ManualStatus @default(DRAFT)
  metadata  Json? // Additional manual metadata
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  // Relations
  orderId         String?
  order           Order?         @relation(fields: [orderId], references: [id], onDelete: SetNull)
  configurationId String?
  configuration   Configuration? @relation(fields: [configurationId], references: [id], onDelete: SetNull)
  componentId     String?
  component       Component?     @relation(fields: [componentId], references: [id], onDelete: SetNull)

  @@map("manuals")
}

enum ManualFormat {
  HTML
  PDF
  MARKDOWN
}

enum ManualStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

// Audit log
model AuditLog {
  id        String   @id @default(cuid())
  action    String
  entity    String // table name
  entityId  String? // record ID
  changes   Json? // what changed
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  metadata  Json? // additional context
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  @@map("audit_logs")
}

// Auth: Refresh tokens for JWT rotation
model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  isRevoked Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("refresh_tokens")
}

// Auth: Password reset tokens
model PasswordReset {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@map("password_resets")
}

// Auth: Email verification tokens
model EmailVerification {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@map("email_verifications")
}

// Auth: Login attempts tracking for rate limiting
model LoginAttempt {
  id        String   @id @default(cuid())
  email     String
  ipAddress String
  userAgent String?
  success   Boolean
  createdAt DateTime @default(now())

  @@map("login_attempts")
}

// Auth: Session management with device tracking
model Session {
  id                String    @id @default(cuid())
  userId            String
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceFingerprint String
  ipAddress         String
  userAgent         String
  rememberMe        Boolean   @default(false)
  isActive          Boolean   @default(true)
  lastActivity      DateTime  @default(now())
  terminatedAt      DateTime?
  expiresAt         DateTime
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@map("sessions")
}

// Auth: Trusted devices for security
model TrustedDevice {
  id                String   @id @default(cuid())
  userId            String
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  deviceFingerprint String
  deviceName        String?
  trustedAt         DateTime @default(now())
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([userId, deviceFingerprint])
  @@map("trusted_devices")
}
