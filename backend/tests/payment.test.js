import { describe, test, expect, beforeAll, afterAll, beforeEach } from '@jest/globals';\nimport request from 'supertest';\nimport app from '../src/app.js';\nimport PaymentService from '../src/services/paymentService.js';\nimport { OrderRepository } from '../src/repositories/index.js';\n\n// Mock payment service for testing\njest.mock('../src/services/paymentService.js');\njest.mock('../src/repositories/index.js');\n\nconst MockPaymentService = PaymentService;\nconst MockOrderRepository = OrderRepository;\n\ndescribe('Payment Integration Tests', () => {\n  let authToken;\n  let testUser = {\n    id: 'test-user-id',\n    email: 'test@example.com',\n    name: 'Test User',\n    role: 'USER'\n  };\n  \n  let testOrder = {\n    id: 'test-order-id',\n    userId: testUser.id,\n    totalPrice: 99.99,\n    currency: 'EUR',\n    status: 'PENDING',\n    paymentStatus: 'PENDING',\n    items: [\n      {\n        name: 'Test Robot Kit',\n        quantity: 1,\n        price: 99.99\n      }\n    ]\n  };\n\n  beforeAll(async () => {\n    // Setup test authentication token\n    authToken = 'test-jwt-token';\n  });\n\n  beforeEach(() => {\n    // Reset mocks before each test\n    jest.clearAllMocks();\n    \n    // Setup common mock implementations\n    MockOrderRepository.mockImplementation(() => ({\n      findById: jest.fn().mockResolvedValue(testOrder),\n      updatePaymentId: jest.fn().mockResolvedValue(true),\n      updatePaymentStatus: jest.fn().mockResolvedValue(true),\n      updateStatus: jest.fn().mockResolvedValue(true),\n      addPayment: jest.fn().mockResolvedValue(true),\n      findAll: jest.fn().mockResolvedValue([testOrder]),\n      getPayments: jest.fn().mockResolvedValue([])\n    }));\n    \n    MockPaymentService.mockImplementation(() => ({\n      createPaymentIntent: jest.fn(),\n      confirmPayment: jest.fn(),\n      refundPayment: jest.fn(),\n      getPaymentMethods: jest.fn(),\n      getProviderStatus: jest.fn(),\n      validateWebhookSignature: jest.fn()\n    }));\n  });\n\n  describe('Payment Methods', () => {\n    test('GET /api/payment/methods should return available payment methods', async () => {\n      const mockMethods = [\n        { id: 'stripe', name: 'Credit Card', enabled: true },\n        { id: 'paypal', name: 'PayPal', enabled: true }\n      ];\n      \n      MockPaymentService.mockImplementationOnce(() => ({\n        getPaymentMethods: jest.fn().mockResolvedValue(mockMethods)\n      }));\n\n      const response = await request(app)\n        .get('/api/payment/methods')\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data.methods).toEqual(mockMethods);\n    });\n  });\n\n  describe('Payment Intent Creation', () => {\n    test('POST /api/payment/create-intent should create Stripe payment intent', async () => {\n      const mockPaymentIntent = {\n        clientSecret: 'pi_test_client_secret',\n        paymentIntentId: 'pi_test_payment_intent',\n        amount: 99.99,\n        currency: 'eur',\n        provider: 'stripe'\n      };\n      \n      MockPaymentService.mockImplementationOnce(() => ({\n        createPaymentIntent: jest.fn().mockResolvedValue(mockPaymentIntent)\n      }));\n\n      // Mock authentication middleware\n      jest.doMock('../src/middleware/auth.js', () => ({\n        auth: (req, res, next) => {\n          req.user = testUser;\n          next();\n        }\n      }));\n\n      const response = await request(app)\n        .post('/api/payment/create-intent')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          orderId: testOrder.id,\n          paymentMethod: 'stripe'\n        })\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data).toEqual(mockPaymentIntent);\n    });\n\n    test('POST /api/payment/create-intent should create PayPal payment', async () => {\n      const mockPayPalPayment = {\n        approvalUrl: 'https://sandbox.paypal.com/checkoutnow?token=test',\n        paymentId: 'PAY_TEST_123',\n        amount: 99.99,\n        currency: 'EUR',\n        provider: 'paypal'\n      };\n      \n      MockPaymentService.mockImplementationOnce(() => ({\n        createPaymentIntent: jest.fn().mockResolvedValue(mockPayPalPayment)\n      }));\n\n      const response = await request(app)\n        .post('/api/payment/create-intent')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          orderId: testOrder.id,\n          paymentMethod: 'paypal'\n        })\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data).toEqual(mockPayPalPayment);\n    });\n\n    test('POST /api/payment/create-intent should return 404 for non-existent order', async () => {\n      MockOrderRepository.mockImplementationOnce(() => ({\n        findById: jest.fn().mockResolvedValue(null)\n      }));\n\n      const response = await request(app)\n        .post('/api/payment/create-intent')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          orderId: 'non-existent-order',\n          paymentMethod: 'stripe'\n        })\n        .expect(404);\n\n      expect(response.body.error).toBe('Order not found');\n    });\n\n    test('POST /api/payment/create-intent should return 400 for already paid order', async () => {\n      const paidOrder = { ...testOrder, paymentStatus: 'COMPLETED' };\n      \n      MockOrderRepository.mockImplementationOnce(() => ({\n        findById: jest.fn().mockResolvedValue(paidOrder)\n      }));\n\n      const response = await request(app)\n        .post('/api/payment/create-intent')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          orderId: testOrder.id,\n          paymentMethod: 'stripe'\n        })\n        .expect(400);\n\n      expect(response.body.error).toBe('Order already paid');\n    });\n  });\n\n  describe('Payment Confirmation', () => {\n    test('POST /api/payment/confirm should confirm Stripe payment', async () => {\n      const mockConfirmation = {\n        status: 'succeeded',\n        amount: 99.99,\n        currency: 'eur',\n        paymentId: 'pi_test_payment_intent',\n        provider: 'stripe'\n      };\n      \n      MockPaymentService.mockImplementationOnce(() => ({\n        confirmPayment: jest.fn().mockResolvedValue(mockConfirmation)\n      }));\n\n      const response = await request(app)\n        .post('/api/payment/confirm')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          paymentId: 'pi_test_payment_intent',\n          paymentMethod: 'stripe'\n        })\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data).toEqual(mockConfirmation);\n    });\n\n    test('POST /api/payment/confirm should confirm PayPal payment', async () => {\n      const mockConfirmation = {\n        status: 'succeeded',\n        amount: 99.99,\n        currency: 'EUR',\n        paymentId: 'PAY_TEST_123',\n        provider: 'paypal'\n      };\n      \n      MockPaymentService.mockImplementationOnce(() => ({\n        confirmPayment: jest.fn().mockResolvedValue(mockConfirmation)\n      }));\n\n      const response = await request(app)\n        .post('/api/payment/confirm')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          paymentId: 'PAY_TEST_123',\n          paymentMethod: 'paypal'\n        })\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data).toEqual(mockConfirmation);\n    });\n  });\n\n  describe('Payment Refunds', () => {\n    test('POST /api/payment/refund should process refund for admin users', async () => {\n      const adminUser = { ...testUser, role: 'ADMIN' };\n      const mockRefund = {\n        refundId: 'ref_test_123',\n        amount: 99.99,\n        currency: 'eur',\n        status: 'succeeded',\n        provider: 'stripe'\n      };\n      \n      MockPaymentService.mockImplementationOnce(() => ({\n        refundPayment: jest.fn().mockResolvedValue(mockRefund)\n      }));\n      \n      MockOrderRepository.mockImplementationOnce(() => ({\n        findById: jest.fn().mockResolvedValue({ ...testOrder, paymentStatus: 'COMPLETED' }),\n        getPayments: jest.fn().mockResolvedValue([{\n          paymentId: 'pi_test_payment_intent',\n          provider: 'stripe',\n          status: 'COMPLETED'\n        }]),\n        updatePaymentStatus: jest.fn().mockResolvedValue(true),\n        updateStatus: jest.fn().mockResolvedValue(true)\n      }));\n\n      // Mock admin authentication\n      jest.doMock('../src/middleware/auth.js', () => ({\n        auth: (req, res, next) => {\n          req.user = adminUser;\n          next();\n        }\n      }));\n\n      const response = await request(app)\n        .post('/api/payment/refund')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          orderId: testOrder.id,\n          amount: 99.99,\n          reason: 'Customer requested refund'\n        })\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data).toEqual(mockRefund);\n    });\n\n    test('POST /api/payment/refund should return 403 for non-admin users', async () => {\n      const response = await request(app)\n        .post('/api/payment/refund')\n        .set('Authorization', `Bearer ${authToken}`)\n        .send({\n          orderId: testOrder.id,\n          amount: 99.99,\n          reason: 'Customer requested refund'\n        })\n        .expect(403);\n\n      expect(response.body.error).toBe('Admin access required');\n    });\n  });\n\n  describe('Webhook Handling', () => {\n    test('POST /api/payment/stripe/webhook should handle valid Stripe webhook', async () => {\n      const mockStripeEvent = {\n        id: 'evt_test_webhook',\n        type: 'payment_intent.succeeded',\n        data: {\n          object: {\n            id: 'pi_test_payment_intent',\n            amount: 9999, // in cents\n            currency: 'eur',\n            metadata: {\n              orderId: testOrder.id\n            }\n          }\n        }\n      };\n      \n      MockPaymentService.mockImplementationOnce(() => ({\n        validateWebhookSignature: jest.fn().mockResolvedValue(mockStripeEvent)\n      }));\n\n      const response = await request(app)\n        .post('/api/payment/stripe/webhook')\n        .set('stripe-signature', 'test_signature')\n        .set('Content-Type', 'application/json')\n        .send(JSON.stringify(mockStripeEvent))\n        .expect(200);\n\n      expect(response.body.received).toBe(true);\n    });\n\n    test('POST /api/payment/paypal/webhook should handle valid PayPal webhook', async () => {\n      const mockPayPalEvent = {\n        id: 'WH-test-webhook',\n        event_type: 'PAYMENT.CAPTURE.COMPLETED',\n        resource: {\n          id: 'CAPTURE_TEST_123',\n          amount: {\n            value: '99.99',\n            currency_code: 'EUR'\n          }\n        }\n      };\n      \n      MockPaymentService.mockImplementationOnce(() => ({\n        validateWebhookSignature: jest.fn().mockResolvedValue(mockPayPalEvent)\n      }));\n\n      const response = await request(app)\n        .post('/api/payment/paypal/webhook')\n        .send(mockPayPalEvent)\n        .expect(200);\n\n      expect(response.body.received).toBe(true);\n    });\n\n    test('POST /api/payment/stripe/webhook should return 400 for invalid signature', async () => {\n      MockPaymentService.mockImplementationOnce(() => ({\n        validateWebhookSignature: jest.fn().mockRejectedValue(new Error('Invalid signature'))\n      }));\n\n      const response = await request(app)\n        .post('/api/payment/stripe/webhook')\n        .set('stripe-signature', 'invalid_signature')\n        .set('Content-Type', 'application/json')\n        .send(JSON.stringify({ type: 'test' }))\n        .expect(400);\n\n      expect(response.text).toBe('Webhook signature verification failed');\n    });\n  });\n\n  describe('Payment Provider Status', () => {\n    test('GET /api/payment/status should return provider status for admin', async () => {\n      const adminUser = { ...testUser, role: 'ADMIN' };\n      const mockStatus = {\n        stripe: {\n          enabled: true,\n          configured: true,\n          webhookConfigured: true\n        },\n        paypal: {\n          enabled: true,\n          configured: true,\n          webhookConfigured: false\n        }\n      };\n      \n      MockPaymentService.mockImplementationOnce(() => ({\n        getProviderStatus: jest.fn().mockReturnValue(mockStatus)\n      }));\n\n      // Mock admin authentication\n      jest.doMock('../src/middleware/auth.js', () => ({\n        auth: (req, res, next) => {\n          req.user = adminUser;\n          next();\n        }\n      }));\n\n      const response = await request(app)\n        .get('/api/payment/status')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(200);\n\n      expect(response.body.success).toBe(true);\n      expect(response.body.data).toEqual(mockStatus);\n    });\n\n    test('GET /api/payment/status should return 403 for non-admin users', async () => {\n      const response = await request(app)\n        .get('/api/payment/status')\n        .set('Authorization', `Bearer ${authToken}`)\n        .expect(403);\n\n      expect(response.body.error).toBe('Admin access required');\n    });\n  });\n});\n\ndescribe('PaymentService Unit Tests', () => {\n  let paymentService;\n\n  beforeEach(() => {\n    // Create fresh instance for each test\n    jest.clearAllMocks();\n    paymentService = new PaymentService();\n  });\n\n  describe('Payment Method Detection', () => {\n    test('should detect enabled payment methods based on environment variables', () => {\n      process.env.STRIPE_SECRET_KEY = 'sk_test_123';\n      process.env.PAYPAL_CLIENT_ID = 'paypal_client_id';\n      \n      const service = new PaymentService();\n      \n      expect(service.stripeEnabled).toBe(true);\n      expect(service.paypalEnabled).toBe(true);\n    });\n\n    test('should disable payment methods when credentials missing', () => {\n      delete process.env.STRIPE_SECRET_KEY;\n      delete process.env.PAYPAL_CLIENT_ID;\n      \n      const service = new PaymentService();\n      \n      expect(service.stripeEnabled).toBe(false);\n      expect(service.paypalEnabled).toBe(false);\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('should throw error for unsupported payment method', async () => {\n      const orderData = {\n        total: 99.99,\n        currency: 'eur',\n        orderId: 'test-order-id'\n      };\n\n      await expect(\n        paymentService.createPaymentIntent(orderData, 'unsupported')\n      ).rejects.toThrow('Unsupported payment method: unsupported');\n    });\n\n    test('should throw error when Stripe not configured', async () => {\n      paymentService.stripeEnabled = false;\n      \n      const orderData = {\n        total: 99.99,\n        currency: 'eur',\n        orderId: 'test-order-id'\n      };\n\n      await expect(\n        paymentService.createStripePaymentIntent(orderData)\n      ).rejects.toThrow('Stripe payment is not configured');\n    });\n\n    test('should throw error when PayPal not configured', async () => {\n      paymentService.paypalEnabled = false;\n      \n      const orderData = {\n        total: 99.99,\n        currency: 'EUR',\n        orderId: 'test-order-id'\n      };\n\n      await expect(\n        paymentService.createPayPalPayment(orderData)\n      ).rejects.toThrow('PayPal payment is not configured');\n    });\n  });\n});